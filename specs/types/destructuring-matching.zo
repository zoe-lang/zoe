
// structs can be destructured into variables
fn test() {
  var person = Person(name = "toto", age = 10)
  // a field can be renamed
  var (name, age2 = age) = person
  // fields can be omitted
  var (age) = person

  //
  var person_or_cat: (Person | Cat) = get()

  if (person_or_cat is Person) {
    // type of person_or_get is narrowed inside the block to Person
    // we can now destructurize the person_or_cat variable
    var (name, age) = person_or_cat
  }

  var something_that_says: #says = get_says()

  // The following will error if Person does not implement #says
  if (something_that_says is Person) {
    // something_that_says is narrowed to type Person in that block
  }

  // [...]
  var node: Exp = parse(some_file)

  // This is more compact than doing a series of if ... else if ... else ...
  // and it can be optimized at compile time to switch jumps
  // It also errors if not all cases are covered when the switch is on a sum type
  // It will not error when the switch is on a trait and not all cases are covered because the compiler can't know if they are
  switch node
    // In a switch arm, there is no need to respecify Exp. everywhere
    | BinOp -> { 2 }
    | UnaryOp -> { 1 }
    | else -> 10

  var int = 10
}
