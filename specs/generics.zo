#(
  There are generics in Zoe, though they're simple.
#)

#(?
  (decl:fn test
    (template (lst $T)
      (fndef
        (signature (lst (: a $T)) $T)
        (block)
      )
    )
  )
#)
fn test@$T(a: $T) -> $T { }

# ???
$if $.target == 'windows' {
  type MyType = generic $T struct {

  }
}


#(?
  (decl:type MyType
    (template (lst $T $U)
      (struct (: field $T) (: field2 $U))
    )
  )
#)
type MyType@($T, $U) = struct (
  field: $T
  field2: $U
)

#(?
  (decl:var t
    (@
      (lst String Int)
      MyType
    )
  )
#)
var t MyType@(String, Int)


############ Compile time
# Objectives :
#   - introspect types statically, before compilation, to create different behaviours in generic functions
#   - compile time must be clearly different from runtime code to indicate the staticity
#   - there are restrictions on what is creatable at compile time...

# At compile time, types are introspectable. These statements are inlined
fn toString@$U(u: $U) -> String {
  $.log('this method is deprecated') # compile time log
  if $.hasTrait(u, Stringable) { # if is inline since it only contains comptime expressions
    return u@Stringable.toString()
  }

  let res = StringBuffer()

  if let $cvar = $.asTrait($U) { # Probably should be some compiler intrinsics instead...
    res.write("{$.name($U)}\{")
    for $method in $.methods($cvar) { # for is inlined
      res.write("{$.name($method)}({
        $method.args.map($a => "{$.name($a)}: {$.name($.type($a)}").join(', ')
        }) -> {$method.return_type}")
      )
    }
  }

  return res.getString()
}