#(?

  AT THE BEGINNING, LET'S JUST HAVE SOME BIG CONTINUOUS ALLOCATOR TO FLESH OUT STUFF.

  Whatever happens, we will need some solid escape analisis, if only for the fact
  that there is no explicit heap allocation.

  Prevent array decay ; addresses of indexed elements from a slice or array
  may not outlive their parent variable (and like the rest of pointers, may not
  cross region boundaries). The same goes for structures ; pointers to a non-pointer
  part of a structure follows the same rule !

  Three possibilities to write concurrent code ;
   - @manual, a manually managed space, where the user is expected to perform
     his own stop-the-world GC
   - copy between coroutines, the simplest, default approach, where memory is manually
     copied into the destination (and the root is made available once it is done)
   - @named regions, where whole regions are transfered to other coroutines.
     The main interest is that a named region can be prepared/manipulated in complex
     ways before being sent, and that work can be actually distributed.

  Always possible to opt out from separate buckets ; just have the data be copied,
  which will be transparent to the user, which is the recommanded case for
  small data sets (that get copied quick).

  Possible to treat the type as non-null, but then it is impossible to give it.
  Unique ptrs may not be given (escape) to *anything* when they're treated as
  non-null, because that means ultimately their reference cannot be erased.

  * Unique ptr is necessarily a root to its own bucket
  * Unique ptr is necessarily put in a unique*Type | null container
  * Unique ptr can be passed as a non-null, non-unique pointer receiver if and
      only if the receiver cannot outlive it and cannot cross boundaries.

  ## We need a precise GC !

  ## What GC is used ?

  Buckets !

  Issues faced ;
   - Synchronizing garbage collectors leads to pause-the-world
   - Heaps have to be isolated to not have to synchronize them
   - Heap pointers may not point to another heap
   - Traditionally, data needs to be copied between heaps to avoid having references
     - This gets prohibitive when data is complex (think linked list, etc.), because
       copy has to traverse all the structures and create new references/allocate/etc.

   : So we share heaps instead of variables. Only one greenlet accesses a given heap
     at a time.
      - Heaps can be passed around, but then a greenlet may not have *any* reference
        left to a heap it gave to another greenlet, unless the heap contains data
        that is completely immutable (? but then we can't deallocate it.)
      - We need to find a way to *prevent* completely pointer sharing.

    - It is very much possible to get another region and merge it into @local,
      treating its blocks as part of the local blocks.

  ## When does a pointer escape ?
   * distinction between escaping from the stack, and escaping to another heap.
   * Escapes when returned from a scope (at least from the scope)
   * Escapes when aliased into a container (such as a struct or array)
   * When aliased into another variable (who may itself escape)

  ## Isolated regions
   * Can not have pointers to other regions. Other regions may not point to them
   * Can be merged
#)

fn main() {
  var myvar = isolate {
    # Do a lot of stuff in isolation
    # The result of this block is an isolated root to something.
  }

  isolate myvar {
    # When in a variable isolate, we lock ourselves to its region

  }

  # take myvar ends myvar's isolate status
  var pouet = take myvar

  var myvar2 = isolate {
    # Any allocation done in the isolate pertains to its memory region
  }

  const pouet = isolate {
    var p = take myvar2 # We conflate this isolate into our own.
    # myvar2 is now null and its memory lost its isolate status.

    # This makes an immutable variable, that we can prepare
    # by mutating stuff all we want.
    # Once we reach the end of this scope, whatever was created here
    # won't be modifiable anymore.
    "hello !"
  }

  # Do const isolates need to be ARC ?
}

#(?
  Variables may be marked as pertaining to another memory region, or bucket.
  Buckets are memory pages that are distinct from the default heap given to each
  greenlet, that are meant to be given to other greenlets with their contents. lllrfc/kkkss

  The rule to do that is that to give a bucket to another greenlet, no references
  towards the bucket may remain.

    * A bucket may *not* have a pointer that references memory from another bucket.''
    * At any given time, a bucket is referenced by exactly one greenlet.

  There might be some give / take semantics, that force a null

  There could be a way to create permanent, immutable regions at run time, that could
  be shared across greenlets, since there would be no more memory management done
  in them. The whole block could be garbage collected prior to be turned into an
  immutable one and then turned into one, big, Atomically Reference Counted structure.

  The compiler could track when a pointer is being stored in another structure (how ?)
  to know what functions create reference to other buckets and prohibit calling
  them with different regions.

  For instance, .push() on a slice that holds pointers or a structure that holds pointers.

  There could be an @unmanaged bucket, where all memory management has to be done completly
  manually with malloc/free or equivalent and where locking and unlocking is completly manual.
  This would be unsafe by design. Probably all C code that is called would be done in
  this memory region and imlementors would have to take care to make their code more suitable
  for safe use.

  The idea would be to make region management completely invisible when running single
  greenlet code, and as unobtrusive as possible when running concurrent code.

  The current region allocator is stored in a thread local that is updated by the
  runtime whenever it swaps greenlets, and updated by greenlets themselves whenever
  they change regions.

  *** Ideas

   - A 'unique' pointer type, that is necessarily | null, which can then be given.
   - give in one swoop sets the variable to null
   - send() expects either something that can be copied or a unique pointer to some data

   How are "unique" pointers handled in closures ?
   For instance, I may want to have it run inside an fn () callback as being closed upon.
   Rust uses life times for that, but I might just get away with assignment analysis.
   For instance, if the closure doesn't escape the current scope, then that's ok.

#)
fn pouet() {
  # local is special.
  const a = @local
  const myvar @reg1 = [1, 2, 3]
  const myother_var @reg2 = [myvar] # illegal !
  const stuff = Slice.new@reg2() # @region only possible on fn, not methods, which are bound to the region of their variable

  # Inside a region block, we can have as many aliases to pointers
  # of a given region
  var stuff = @tosend {
    var res = Slice.new()
    # In this scope, we set the default region as @tosend
    # So push@tosend, but also createVar@tosend
    res.push(create_var())
    res
  }

  # I can now use stuff with all its const methods

  othergreenlet.send(stuff)

  # In toplevel scope, we have so specify stuff
  stuff.push(create_var@reg2())

  # Can I enforce this ?
  # Only if stuff was owned by the current scope.
  # Holy shit this is turning into Rust again. Except rust deals with granular life times, we just deal with
  # memory regions, so this ought to be a little less complicated.
  if stuff != null {
    other_process.send(give stuff)
    # For the rest of the block stuff is now null
  }
  stuff.doSomething()
}


struct Greenlet[$Send, $Receive] {

  current_region: Int
  fun: fn (green: this) -> nothing

  fn create[$Send, $Receive]() -> Greenlet[$Send, $Receive] {

  }

  # This has to be implemented ?
  method run() -> Error | null

  method receive() -> $Receive | Error {

  }

  # ???
  method send(sendable: owned $Send) -> Error | null {

  }
}


struct Slice[$T] {
  # What about closures and global variables ?
  # What regions do they pertain to ?

  method push(value: $T) {
    # An assignment.
    # So we can track a this expression that receives a value
    # In here, ptr integrates value. And ptr is integrated inside this,
    # hence value is integrated by this.
    # So Slice[$T].push() integrates `value`.
    this.ptr[idx] = value
  }
}

fn pouet(slc: Slice[*Int], other: *Int) {
  slc.push(other) # push may integrate its argument

  # This runs on its own context, this operation creates the new int in the
  # same region as the function is running in.
  # This would still be an error with regions because by default a function runs in @local
  # Unless the function was executed in the same region as slc (this is the default with methods).
  var a = Int(other.*)
  slc.push(&a)
}

# How can we have a pointer to an owned pointer ?

fn receiver(channel: Channel[...]) {

  @other {
    while true {
      var v = channel.receive() # So what if we receive a unique pointer ?
    }
  }

}
